<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>SockLib: Référence de la classe socklib::ReaderWriter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SockLib
   </div>
   <div id="projectbrief">Librairie d&#39;application pour le cours de système en L2 informatique à l&#39;UCBL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Page&#160;principale</span></a></li>
      <li><a href="namespaces.html"><span>Espaces&#160;de&#160;nommage</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Fichiers</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Recherche" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Liste&#160;des&#160;classes</span></a></li>
      <li><a href="classes.html"><span>Index&#160;des&#160;classes</span></a></li>
      <li><a href="functions.html"><span>Membres&#160;de&#160;classe</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesocklib.html">socklib</a></li><li class="navelem"><a class="el" href="classsocklib_1_1ReaderWriter.html">ReaderWriter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Fonctions membres publiques</a> &#124;
<a href="#pri-attribs">Attributs privés</a> &#124;
<a href="#friends">Amis</a> &#124;
<a href="classsocklib_1_1ReaderWriter-members.html">Liste de tous les membres</a>  </div>
  <div class="headertitle">
<div class="title">Référence de la classe socklib::ReaderWriter</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classe interne de lecteur sur un descripteur de fichier sans buffer.  
 <a href="classsocklib_1_1ReaderWriter.html#details">Plus de détails...</a></p>

<p><code>#include &lt;<a class="el" href="readerwriter_8hpp_source.html">readerwriter.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Fonctions membres publiques</h2></td></tr>
<tr class="memitem:a6e71372143ea8a91197350d3bc6534a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsocklib_1_1ReaderWriter.html#a6e71372143ea8a91197350d3bc6534a9">ReaderWriter</a> (int <a class="el" href="classsocklib_1_1ReaderWriter.html#af6157b720c1a724d0ec2382297f77a3b">fd</a>)</td></tr>
<tr class="memdesc:a6e71372143ea8a91197350d3bc6534a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructeur à partir d'un file descriptor  <a href="#a6e71372143ea8a91197350d3bc6534a9">Plus de détails...</a><br /></td></tr>
<tr class="separator:a6e71372143ea8a91197350d3bc6534a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774b72234d767f1a12e4d5217cc7bc72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsocklib_1_1ReaderWriter.html#a774b72234d767f1a12e4d5217cc7bc72">close</a> ()</td></tr>
<tr class="memdesc:a774b72234d767f1a12e4d5217cc7bc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">fermeture du flux  <a href="#a774b72234d767f1a12e4d5217cc7bc72">Plus de détails...</a><br /></td></tr>
<tr class="separator:a774b72234d767f1a12e4d5217cc7bc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae973cbac1cc92d250765b062f0a67fd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsocklib_1_1ReaderWriter.html#ae973cbac1cc92d250765b062f0a67fd0">test_and_read</a> (char *buff, int offset, int len)</td></tr>
<tr class="memdesc:ae973cbac1cc92d250765b062f0a67fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">test s'il y a qqchose à lire en modifiant le comportement pour le rendre non blocant.  <a href="#ae973cbac1cc92d250765b062f0a67fd0">Plus de détails...</a><br /></td></tr>
<tr class="separator:ae973cbac1cc92d250765b062f0a67fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e96ea528c035cc2bd80f3f7c5898c10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsocklib_1_1ReaderWriter.html#a0e96ea528c035cc2bd80f3f7c5898c10">read</a> (std::vector&lt; char &gt; &amp;buff, bool wait_all=false)</td></tr>
<tr class="memdesc:a0e96ea528c035cc2bd80f3f7c5898c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">lire des données arrivées  <a href="#a0e96ea528c035cc2bd80f3f7c5898c10">Plus de détails...</a><br /></td></tr>
<tr class="separator:a0e96ea528c035cc2bd80f3f7c5898c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcede0113a86f21bb39abb1cda3e62df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsocklib_1_1ReaderWriter.html#abcede0113a86f21bb39abb1cda3e62df">read</a> (char *buff, int offset, int len, bool wait_all=false)</td></tr>
<tr class="memdesc:abcede0113a86f21bb39abb1cda3e62df"><td class="mdescLeft">&#160;</td><td class="mdescRight">lire des données arrivées dans un buffer  <a href="#abcede0113a86f21bb39abb1cda3e62df">Plus de détails...</a><br /></td></tr>
<tr class="separator:abcede0113a86f21bb39abb1cda3e62df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f74dc7132f061352dc8a6e277fced5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsocklib_1_1ReaderWriter.html#a55f74dc7132f061352dc8a6e277fced5">write</a> (const std::vector&lt; char &gt; &amp;buff)</td></tr>
<tr class="memdesc:a55f74dc7132f061352dc8a6e277fced5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ecriture de données  <a href="#a55f74dc7132f061352dc8a6e277fced5">Plus de détails...</a><br /></td></tr>
<tr class="separator:a55f74dc7132f061352dc8a6e277fced5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7078e6ce59eb11e6b62fc0c1d17736fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsocklib_1_1ReaderWriter.html#a7078e6ce59eb11e6b62fc0c1d17736fe">write</a> (const char *buff, int offset, int len)</td></tr>
<tr class="memdesc:a7078e6ce59eb11e6b62fc0c1d17736fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">ecriture de données  <a href="#a7078e6ce59eb11e6b62fc0c1d17736fe">Plus de détails...</a><br /></td></tr>
<tr class="separator:a7078e6ce59eb11e6b62fc0c1d17736fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Attributs privés</h2></td></tr>
<tr class="memitem:af6157b720c1a724d0ec2382297f77a3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsocklib_1_1ReaderWriter.html#af6157b720c1a724d0ec2382297f77a3b">fd</a></td></tr>
<tr class="separator:af6157b720c1a724d0ec2382297f77a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Amis</h2></td></tr>
<tr class="memitem:aa29fa811fdbde99f1ecad0642f4a6fae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsocklib_1_1ReaderWriter.html#aa29fa811fdbde99f1ecad0642f4a6fae">std::swap</a> (<a class="el" href="classsocklib_1_1ReaderWriter.html">ReaderWriter</a> &amp;a, <a class="el" href="classsocklib_1_1ReaderWriter.html">ReaderWriter</a> &amp;b)</td></tr>
<tr class="memdesc:aa29fa811fdbde99f1ecad0642f4a6fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">échange de 2 <code><a class="el" href="classsocklib_1_1ReaderWriter.html" title="Classe interne de lecteur sur un descripteur de fichier sans buffer. ">ReaderWriter</a></code>  <a href="#aa29fa811fdbde99f1ecad0642f4a6fae">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa29fa811fdbde99f1ecad0642f4a6fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description détaillée</h2>
<div class="textblock"><p>Classe interne de lecteur sur un descripteur de fichier sans buffer. </p>
<dl class="section see"><dt>Voir également</dt><dd><a class="el" href="classsocklib_1_1BufferedReaderWriter.html" title="classe de gestion des entrées sorties bufferisées ">BufferedReaderWriter</a></dd></dl>
<p>Cette classe n'est prévue que pour être utilisée dans le la classe de données bufferisées : <a class="el" href="classsocklib_1_1BufferedReaderWriter.html" title="classe de gestion des entrées sorties bufferisées ">BufferedReaderWriter</a> Cette classe est simplifiée plutot basée sur le fonctionnement des sockets C. Elle est définie pour proposer une lecture et une écriture même sur les FDs qui ne permettent que l'un des deux (fichier ouvert en lecture, pipe, ...). Dans le cas de l'appel à la fonction lecture ou ériture alors que c'est impossible, cela génèrera des exceptions. </p>
</div><h2 class="groupheader">Documentation des constructeurs et destructeur</h2>
<a class="anchor" id="a6e71372143ea8a91197350d3bc6534a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">socklib::ReaderWriter::ReaderWriter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructeur à partir d'un file descriptor </p>

</div>
</div>
<h2 class="groupheader">Documentation des fonctions membres</h2>
<a class="anchor" id="a774b72234d767f1a12e4d5217cc7bc72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void socklib::ReaderWriter::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fermeture du flux </p>

</div>
</div>
<a class="anchor" id="a0e96ea528c035cc2bd80f3f7c5898c10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int socklib::ReaderWriter::read </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_all</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>lire des données arrivées </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>: le vector où stocker les données, </td></tr>
    <tr><td class="paramname">wait_all</td><td>: attendre que toutes les données </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">une</td><td>std::runtime_error si le fd se ferme alors qu'on attend encore des données ou une std::error_condition s'il y a une erreur d'entrée sortie</td></tr>
  </table>
  </dd>
</dl>
<p>Cette méthode lit les données par un seul read, le buffer doit avoir une taille de départ, qui sera le nombre d'octets lus au maximum. Si wait_all est ''true'' la foctione attend que tout les octets soient arrivés. </p>

</div>
</div>
<a class="anchor" id="abcede0113a86f21bb39abb1cda3e62df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int socklib::ReaderWriter::read </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_all</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>lire des données arrivées dans un buffer </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>: le char * où stocker les données, </td></tr>
    <tr><td class="paramname">offset</td><td>: la position où commencer de mettre les données </td></tr>
    <tr><td class="paramname">len</td><td>: la taille maximum des données à lire </td></tr>
    <tr><td class="paramname">wait_all</td><td>: attendre que toutes les données </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">une</td><td>std::runtime_error si le fd se ferme alors qu'on attend encore des données ou une std::error_condition s'il y a une erreur d'entrée sortie</td></tr>
  </table>
  </dd>
</dl>
<p>Cette méthode lit les données par un seul read, le buffer doit avoir une taille de départ, qui sera le nombre d'octets lus au maximum. Si wait_all est ''true'' la foctione attend que tout les octets soient arrivés. </p>

</div>
</div>
<a class="anchor" id="ae973cbac1cc92d250765b062f0a67fd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int socklib::ReaderWriter::test_and_read </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>test s'il y a qqchose à lire en modifiant le comportement pour le rendre non blocant. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>: le char * où stocker les données lues s'il ty en a, </td></tr>
    <tr><td class="paramname">offset</td><td>: la position où commencer de mettre les données </td></tr>
    <tr><td class="paramname">len</td><td>: la taille maximum des données à lire. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>le nombre d'octet lu s'il y en a ou 0 si le fd est terminé ou s'il n'y a rien à lire </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">un</td><td>error_system s'il y a une erreur de lecture.</td></tr>
  </table>
  </dd>
</dl>
<p>Cette méthode est forcement non blocante, par contre s'il y a des caractères à lire elle les lit. Dans les man, il est dit que si la longueur demandée est 0, cela PEUT permettre de détecter les erreur. Dans ce cas, cela permettrait de tester sans lire. Mais ce n'est pas dans la norme. </p>

</div>
</div>
<a class="anchor" id="a55f74dc7132f061352dc8a6e277fced5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int socklib::ReaderWriter::write </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ecriture de données </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>: le vecteur de données à écrires </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">une</td><td>erreur si l'ecriture est impossible </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7078e6ce59eb11e6b62fc0c1d17736fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int socklib::ReaderWriter::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ecriture de données </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>: le tableau des données à écrire </td></tr>
    <tr><td class="paramname">offset,len</td><td>: le début des données et leur taille </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">une</td><td>erreur si l'ecriture est impossible </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Documentation des fonctions amies et associées</h2>
<a class="anchor" id="aa29fa811fdbde99f1ecad0642f4a6fae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void std::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsocklib_1_1ReaderWriter.html">ReaderWriter</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsocklib_1_1ReaderWriter.html">ReaderWriter</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>échange de 2 <code><a class="el" href="classsocklib_1_1ReaderWriter.html" title="Classe interne de lecteur sur un descripteur de fichier sans buffer. ">ReaderWriter</a></code> </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b</td><td>: les deux <code><a class="el" href="classsocklib_1_1ReaderWriter.html" title="Classe interne de lecteur sur un descripteur de fichier sans buffer. ">ReaderWriter</a></code> à échanger </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Documentation des données membres</h2>
<a class="anchor" id="af6157b720c1a724d0ec2382297f77a3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int socklib::ReaderWriter::fd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>La documentation de cette classe a été générée à partir des fichiers suivants :<ul>
<li>include/<a class="el" href="readerwriter_8hpp_source.html">readerwriter.hpp</a></li>
<li>src/lib/<a class="el" href="readerwriter_8cpp.html">readerwriter.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
